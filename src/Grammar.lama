import List;
import Ostap;
import Matcher;
import Fun;
import Ref;

-- Creates an empty named grammar
public fun createGrammar (name) {
  ref ([name, {}])
}

public fun addGroup (grammar, name) {
  -- Check if a group with the given name exists
  let [grammarName, entries] = deref (grammar) in
  grammar ::= [grammarName, [name, {["start", empty]}] : entries];
  grammar
}

public fun addEntry (grammar, group, level, expr) {
  let [grammarName, entries] = deref (grammar) in
  let entries =
    map (fun (g@[groupName, groupLevels]) {
           if group = groupName
           then
	     let levels =
	       foldr (fun (levels, entry@[levelName, levelParser]) {
                 case level of
  	           At (name) ->
	             if levelName = name
	             then [levelName, alt (expr, levelParser)]
	             else entry 
	             fi : levels
	         | Before (name, newName) ->
	             if levelName = name
	             then {[newName, expr], entry} 
	             else {entry}
	             fi +++ levels
	         | After (name, newName) ->
	             if levelName = name
	             then {entry, [newName, expr]}  
	             else {entry}
	             fi +++ levels
	         esac
               },
	       {},
	       groupLevels)
	     in
	     [groupName, levels]
	 else g
	 fi
       },
       entries)
  in
  grammar ::= [grammarName, entries];
  grammar
}

public fun entry (grammar, entry, level) {
  let [grammarName, entries] = deref (grammar) in
  case find (fun ([name, _]) {name = entry}, entries) of
    Some ([_, levels]) ->
      case find (fun ([name, _]) {name = level}, levels) of
        Some ([_, expr]) -> expr  
      | None             -> failure (sprintf ("level %s was not found", level))
      esac
  | None -> failure (sprintf ("entry %s was not found in grammar %s", entry, grammarName))
  esac
}
  
